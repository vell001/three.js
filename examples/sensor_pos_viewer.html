<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
	<title>three.js webgl - arcball controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">

</head>

<body>
<div id="info">
	<input type="file" id="load_sensor_config_data"/><br/>
	选中的对象为：<span id="objInfo"></span>
</div>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}











</script>

<script type="module">
	import * as THREE from 'three';

	import {GUI} from 'three/addons/libs/lil-gui.module.min.js';

	import {ArcballControls} from 'three/addons/controls/ArcballControls.js';

	import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
	import {RGBELoader} from 'three/addons/loaders/RGBELoader.js';
	import {TextGeometry} from "./jsm/geometries/TextGeometry.js";
	import {FontLoader} from "./jsm/loaders/FontLoader.js";

	const cameras = ['Orthographic', 'Perspective'];
	const cameraType = {type: 'Perspective'};

	const perspectiveDistance = 5;
	const orthographicDistance = 120;
	let camera, controls, scene, renderer, gui;
	let folderOptions, folderAnimations;
	let sensorConfig;
	let sensorObj = undefined;

	let raycaster;
	const pointer = new THREE.Vector2();
	let INTERSECTED = undefined;


	function onPointerMove(event) {
		pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
		pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
	}

	document.addEventListener('mousemove', onPointerMove);

	function genAxisObj(size, color, name="default") {
		let obj = new THREE.Object3D();
		let axisHelper = new THREE.AxesHelper(size * 5);

		const geometry = new THREE.BoxGeometry(size, size, size);

		const material = new THREE.MeshBasicMaterial({color: color});

		let mesh = new THREE.Mesh(geometry, material);
		obj.add(axisHelper);
		obj.add(mesh);
		let nameObj = createText(name);
		if (nameObj){
			obj.add(nameObj);
		}
		return obj;
	}

	const arcballGui = {

		gizmoVisible: false,

		setArcballControls: function () {

			controls = new ArcballControls(camera, renderer.domElement, scene);
			controls.addEventListener('change', render);

			this.gizmoVisible = false;

			controls.setGizmosVisible(arcballGui.gizmoVisible);
			this.populateGui();

		},

		populateGui: function () {

			folderOptions.add(controls, 'enabled').name('Enable controls');
			folderOptions.add(controls, 'enableGrid').name('Enable Grid');
			folderOptions.add(controls, 'enableRotate').name('Enable rotate');
			folderOptions.add(controls, 'enablePan').name('Enable pan');
			folderOptions.add(controls, 'enableZoom').name('Enable zoom');
			folderOptions.add(controls, 'cursorZoom').name('Cursor zoom');
			folderOptions.add(controls, 'adjustNearFar').name('adjust near/far');
			folderOptions.add(controls, 'scaleFactor', 1.1, 10, 0.1).name('Scale factor');
			folderOptions.add(controls, 'minDistance', 0, 50, 0.5).name('Min distance');
			folderOptions.add(controls, 'maxDistance', 0, 50, 0.5).name('Max distance');
			folderOptions.add(controls, 'minZoom', 0, 50, 0.5).name('Min zoom');
			folderOptions.add(controls, 'maxZoom', 0, 50, 0.5).name('Max zoom');
			folderOptions.add(arcballGui, 'gizmoVisible').name('Show gizmos').onChange(function () {

				controls.setGizmosVisible(arcballGui.gizmoVisible);

			});
			folderOptions.add(controls, 'copyState').name('Copy state(ctrl+c)');
			folderOptions.add(controls, 'pasteState').name('Paste state(ctrl+v)');
			folderOptions.add(controls, 'reset').name('Reset');
			folderAnimations.add(controls, 'enableAnimations').name('Enable anim.');
			folderAnimations.add(controls, 'dampingFactor', 0, 100, 1).name('Damping');
			folderAnimations.add(controls, 'wMax', 0, 100, 1).name('Angular spd');

		}

	};

	const sensorNames = ["front_middle_camera", "MIDDLE_LIDAR", "rtk"]

	function findPose(data, poses) {
		if (data instanceof Array) {
			for (let d in data) {
				findPose(data[d], poses)
			}
		} else if (data instanceof Object) {
			if (data.hasOwnProperty("pose") && data.hasOwnProperty("name")) {
				if (sensorNames.indexOf(data.name) < 0) {
					return
				}
				poses.push(data);
			} else {
				for (let d in data) {
					findPose(data[d], poses)
				}
			}
		}
	}


	function updateSensorObj() {
		if (sensorObj === undefined) {
			sensorObj = new THREE.Object3D();
			scene.add(sensorObj);
		}
		sensorObj.clear();

		let poses = [];
		findPose(sensorConfig, poses)
		console.log(poses)
		for (let i in poses) {
			let p = poses[i];
			let translation = p["pose"]["translation"]
			let attitude = p["pose"]["attitude"]
			if (!attitude.x) {
				attitude.x = 0
			}
			if (!attitude.y) {
				attitude.y = 0
			}
			if (!attitude.z) {
				attitude.z = 0
			}
			if (!attitude.w) {
				attitude.w = 0
			}
			if (!translation.x) {
				translation.x = 0
			}
			if (!translation.y) {
				translation.y = 0
			}
			if (!translation.z) {
				translation.z = 0
			}
			let obj = genAxisObj(0.1, 0xFF0000, p["name"]);
			obj.name = p["name"];
			obj.translateX(translation.x);
			obj.translateY(translation.y);
			obj.translateZ(translation.z);
			const quaternion = new THREE.Quaternion(attitude.x, attitude.y, attitude.z, attitude.w)
			obj.setRotationFromQuaternion(quaternion);
			sensorObj.add(obj);
		}
	}

	document.getElementById("load_sensor_config_data").addEventListener('change', function () {
		if (this.files.length === 0) {
			console.log("no file selected");
			return;
		}
		const reader = new FileReader();
		reader.onload = function () {
			sensorConfig = JSON.parse(reader.result);
			console.log(sensorConfig);
			updateSensorObj();
		}
		reader.readAsText(this.files[0]);
	});

	let fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
		fontWeight = 'bold'; // normal bold
	let font;

	function loadFont() {
		const loader = new FontLoader();
		loader.load('fonts/helvetiker_regular.typeface.json', function (response) {
			font = response;
		});
	}

	loadFont();

	function createText(message, height = 0.2, size=0.2) {
		const matLite = new THREE.MeshBasicMaterial( {
			color: 0x00FF00,
			transparent: true,
			opacity: 0.4,
			side: THREE.DoubleSide
		} );
		if (font===undefined){
			return undefined;
		}
		const shapes = font.generateShapes( message, size );

		const geometry = new THREE.ShapeGeometry( shapes );

		geometry.computeBoundingBox();

		const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );

		geometry.translate( xMid, 0, 0 );

		// make shape ( N.B. edge view not visible )

		const text = new THREE.Mesh( geometry, matLite );
		return text;
	}

	init();

	function init() {

		const container = document.createElement('div');
		document.body.appendChild(container);

		renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);

		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.toneMapping = THREE.ReinhardToneMapping;
		renderer.toneMappingExposure = 3;
		renderer.domElement.style.background = 'linear-gradient( 180deg, rgba( 0,0,0,1 ) 0%, rgba( 128,128,255,1 ) 100% )';
		container.appendChild(renderer.domElement);

		//

		scene = new THREE.Scene();
		scene.add(new THREE.HemisphereLight(0x443333, 0x222233, 4));

		let originObj = genAxisObj(0.1, 0x0000ff)
		scene.add(originObj)
		raycaster = new THREE.Raycaster();

		camera = makePerspectiveCamera();
		camera.position.set(0, 0, perspectiveDistance);
		camera.up = new THREE.Vector3(1, 0, 0)


		window.addEventListener('keydown', onKeyDown);
		window.addEventListener('resize', onWindowResize);

		//

		gui = new GUI();
		gui.add(cameraType, 'type', cameras).name('Choose Camera').onChange(function () {

			setCamera(cameraType.type);

		});

		folderOptions = gui.addFolder('Arcball parameters');
		folderAnimations = folderOptions.addFolder('Animations');

		arcballGui.setArcballControls();

		render();
	}

	function makeOrthographicCamera() {

		const halfFovV = THREE.MathUtils.DEG2RAD * 45 * 0.5;
		const halfFovH = Math.atan((window.innerWidth / window.innerHeight) * Math.tan(halfFovV));

		const halfW = perspectiveDistance * Math.tan(halfFovH);
		const halfH = perspectiveDistance * Math.tan(halfFovV);
		const near = 0.01;
		const far = 2000;
		const newCamera = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, near, far);
		return newCamera;

	}

	function makePerspectiveCamera() {

		const fov = 45;
		const aspect = window.innerWidth / window.innerHeight;
		const near = 0.01;
		const far = 2000;
		const newCamera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		return newCamera;

	}


	function onWindowResize() {

		if (camera.type == 'OrthographicCamera') {

			const halfFovV = THREE.MathUtils.DEG2RAD * 45 * 0.5;
			const halfFovH = Math.atan((window.innerWidth / window.innerHeight) * Math.tan(halfFovV));

			const halfW = perspectiveDistance * Math.tan(halfFovH);
			const halfH = perspectiveDistance * Math.tan(halfFovV);
			camera.left = -halfW;
			camera.right = halfW;
			camera.top = halfH;
			camera.bottom = -halfH;

		} else if (camera.type == 'PerspectiveCamera') {

			camera.aspect = window.innerWidth / window.innerHeight;

		}

		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);

		render();

	}


	function updateChooseInfo() {
		if (INTERSECTED) {
			console.log(INTERSECTED)
			document.getElementById("objInfo").innerText = INTERSECTED.name;
		}
	}

	function render() {
		if (sensorObj) {
			camera.updateMatrixWorld();
			raycaster.setFromCamera(pointer, camera);
			const intersects = raycaster.intersectObjects(sensorObj, false);
			if (intersects.length > 0) {

				if (INTERSECTED !== intersects[0].object) {

					if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);

					INTERSECTED = intersects[0].object;
					INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
					INTERSECTED.material.color.setHex(0xff0000);
					updateChooseInfo();
				}
			}
		}

		renderer.render(scene, camera);
	}

	function onKeyDown(event) {

		if (event.key === 'c') {

			if (event.ctrlKey || event.metaKey) {

				controls.copyState();

			}

		} else if (event.key === 'v') {

			if (event.ctrlKey || event.metaKey) {

				controls.pasteState();

			}

		}

	}

	function setCamera(type) {

		if (type == 'Orthographic') {

			camera = makeOrthographicCamera();
			camera.position.set(0, 0, orthographicDistance);


		} else if (type == 'Perspective') {

			camera = makePerspectiveCamera();
			camera.position.set(0, 0, perspectiveDistance);

		}

		controls.setCamera(camera);

		render();

	}

</script>
</body>
